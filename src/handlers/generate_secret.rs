/*****************************************************************************
 *   Ledger App Boilerplate Rust.
 *   (c) 2023 Ledger SAS.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *****************************************************************************/

use core::default;

use crate::app_ui::secret::ui_display_secret;
use crate::utils::Bip32Path;
use crate::AppSW;
use crate::Instruction;
use ironfish_frost::{
    dkg::round1::{self, PublicPackage},
    dkg::round2::CombinedPublicPackage,
    dkg::round3,
    participant::{Secret, SECRET_LEN},
};

extern crate alloc;
use alloc::vec::Vec;

use ledger_device_sdk::hash::{sha3::Keccak256, HashInit};
use ledger_device_sdk::io::{Comm, Event};
use ledger_device_sdk::random::LedgerRng;
use ledger_device_sdk::{
    ecc::{Secp256k1, SeedDerive},
    io::ApduHeader,
};

const MAX_APDU_SIZE: usize = 255;

fn send_apdu_chunks(comm: &mut Comm, data: &[u8]) -> Result<(), AppSW> {
    let total_size = data.len();
    let mut offset = 0;

    while offset < total_size {
        let end = usize::min(offset + MAX_APDU_SIZE, total_size);
        let chunk = &data[offset..end];
        comm.append(chunk);

        // Send the chunk (you may need to handle the sending mechanism depending on your Comm implementation)
        comm.reply_ok();
        match comm.next_event() {
            Event::Command(Instruction::ContinueApdu) => {}
            _ => return Err(AppSW::ClaNotSupported),
        }

        offset = end;
    }

    Ok(())
}

pub fn handler_generate_secret1(comm: &mut Comm, display: bool) -> Result<(), AppSW> {
    let mut rng = LedgerRng {};

    let secret1 = Secret::random(&mut rng);
    let identity1 = secret1.to_identity();
    let secret2 = Secret::random(&mut rng);
    let identity2 = secret2.to_identity();

    let (_round1_secret_package, package): (Vec<u8>, PublicPackage) =
        round1::round1(&identity1, 2, [&identity1, &identity2], &mut rng).unwrap();

    let round1_secret_slice = &package.serialize()[..];
    if display {
        if !ui_display_secret(round1_secret_slice)? {
            return Err(AppSW::Deny);
        }
    }

    // Send the data in chunks
    send_apdu_chunks(comm, round1_secret_slice)?;

    Ok(())
}

pub fn handler_generate_secret(comm: &mut Comm, display: bool) -> Result<(), AppSW> {
    // let mut rng = LedgerRng {};

    let secret_bytes: [u8; 65] = [
        114, 187, 249, 168, 103, 43, 108, 7, 116, 175, 15, 108, 192, 94, 149, 21, 188, 205, 118,
        159, 21, 30, 237, 55, 89, 87, 67, 19, 216, 245, 75, 28, 206, 194, 46, 238, 191, 228, 106,
        4, 35, 56, 22, 45, 68, 223, 105, 67, 100, 22, 123, 28, 36, 76, 75, 193, 35, 111, 2, 223,
        227, 135, 119, 124, 242,
    ];
    let secret = Secret::deserialize_from(&secret_bytes[..]).unwrap();

    let encrypted_secret_package = [
        186, 199, 249, 57, 92, 215, 245, 13, 84, 15, 12, 2, 145, 174, 16, 115, 127, 131, 134, 108,
        3, 187, 108, 223, 118, 252, 46, 179, 12, 114, 174, 6, 110, 97, 192, 218, 97, 240, 162, 176,
        155, 150, 170, 250, 24, 82, 88, 56, 1, 0, 0, 0, 136, 0, 0, 0, 124, 83, 149, 65, 25, 124,
        169, 118, 177, 57, 53, 66, 186, 119, 102, 17, 102, 27, 49, 206, 240, 223, 218, 73, 64, 56,
        182, 156, 101, 37, 100, 208, 106, 248, 96, 14, 68, 70, 23, 222, 93, 23, 104, 19, 75, 33,
        157, 216, 229, 119, 137, 197, 58, 228, 52, 26, 120, 202, 150, 68, 230, 72, 0, 156, 171,
        111, 90, 195, 183, 71, 173, 102, 125, 210, 47, 38, 91, 234, 158, 58, 246, 51, 182, 135, 4,
        139, 72, 69, 158, 192, 191, 120, 175, 73, 3, 28, 228, 128, 125, 92, 127, 46, 134, 96, 5,
        206, 3, 30, 34, 4, 7, 187, 247, 129, 140, 75, 113, 226, 254, 92, 200, 139, 4, 3, 129, 56,
        95, 16, 220, 114, 202, 71, 161, 180, 101, 4, 0, 58, 49, 34, 101, 190, 59, 20, 20, 119, 100,
        223, 8, 163, 154, 55, 111, 139, 207, 9, 113, 124, 30, 111, 12, 46, 105, 27, 91, 11, 82,
        176,
    ];
    let package1_bytes: [u8; 432] = [
        114, 74, 119, 222, 130, 99, 78, 38, 205, 60, 41, 201, 219, 43, 52, 110, 44, 77, 173, 209,
        211, 24, 150, 205, 114, 137, 152, 201, 0, 183, 124, 109, 217, 186, 199, 249, 57, 92, 215,
        245, 13, 84, 15, 12, 2, 145, 174, 16, 115, 127, 131, 134, 108, 3, 187, 108, 223, 118, 252,
        46, 179, 12, 114, 174, 6, 33, 84, 161, 211, 175, 30, 62, 150, 14, 99, 245, 180, 206, 227,
        15, 89, 135, 196, 8, 48, 174, 82, 34, 131, 224, 227, 229, 236, 53, 45, 160, 195, 219, 83,
        102, 188, 78, 188, 109, 127, 118, 109, 22, 158, 77, 185, 84, 134, 139, 247, 42, 127, 100,
        22, 154, 224, 89, 50, 178, 221, 238, 78, 14, 1, 135, 0, 0, 0, 0, 195, 210, 5, 30, 2, 148,
        205, 167, 159, 122, 176, 22, 41, 106, 80, 76, 205, 162, 179, 53, 227, 132, 64, 184, 30, 54,
        155, 230, 246, 167, 48, 31, 192, 119, 68, 68, 161, 227, 253, 206, 129, 101, 10, 130, 103,
        133, 43, 97, 29, 246, 227, 31, 235, 49, 186, 175, 76, 205, 142, 187, 245, 76, 208, 180, 36,
        10, 200, 7, 12, 64, 173, 156, 18, 5, 51, 219, 197, 47, 248, 34, 2, 74, 231, 128, 59, 111,
        253, 90, 196, 16, 236, 118, 206, 7, 200, 98, 244, 75, 195, 116, 181, 26, 175, 8, 152, 101,
        127, 11, 201, 131, 28, 149, 85, 165, 219, 103, 202, 33, 243, 78, 10, 61, 184, 200, 109,
        211, 129, 133, 149, 166, 34, 123, 244, 9, 152, 0, 0, 0, 229, 69, 170, 160, 233, 50, 40, 76,
        19, 15, 225, 165, 50, 118, 39, 85, 21, 153, 204, 93, 51, 169, 99, 60, 219, 195, 236, 156,
        157, 9, 214, 119, 92, 200, 55, 155, 164, 150, 175, 28, 130, 253, 121, 97, 107, 235, 110,
        227, 2, 0, 0, 0, 32, 0, 0, 0, 207, 143, 106, 136, 116, 20, 70, 25, 234, 201, 120, 150, 224,
        121, 148, 37, 46, 17, 140, 242, 4, 227, 201, 76, 90, 219, 254, 25, 82, 234, 219, 157, 224,
        94, 170, 178, 101, 147, 92, 107, 34, 237, 155, 153, 117, 142, 225, 157, 243, 49, 215, 111,
        31, 115, 143, 220, 130, 237, 99, 70, 88, 238, 253, 160, 198, 208, 167, 226, 157, 79, 151,
        49, 72, 242, 175, 40, 200, 179, 238, 39, 186, 245, 133, 1, 221, 4, 178, 239, 42, 118, 229,
        101, 221, 5, 40, 145, 41, 172, 201, 82, 189, 249, 222, 197,
    ];
    let package1 = PublicPackage::deserialize_from(&package1_bytes[..]).unwrap();
    let package2_bytes: [u8; 432] = [
        114, 47, 118, 27, 67, 116, 82, 234, 125, 80, 5, 23, 107, 34, 74, 188, 122, 185, 128, 46,
        84, 194, 85, 11, 196, 124, 42, 106, 198, 207, 178, 239, 125, 211, 153, 172, 15, 45, 165,
        83, 238, 112, 106, 39, 38, 123, 27, 222, 78, 247, 136, 167, 178, 166, 93, 241, 204, 143,
        54, 49, 94, 198, 146, 12, 2, 235, 110, 74, 14, 199, 134, 138, 59, 77, 169, 1, 110, 37, 162,
        251, 43, 189, 252, 47, 247, 111, 184, 115, 0, 100, 222, 32, 198, 254, 196, 5, 112, 235,
        166, 222, 145, 16, 158, 63, 146, 80, 140, 77, 2, 95, 159, 242, 57, 82, 138, 247, 33, 155,
        8, 11, 62, 221, 227, 105, 197, 113, 214, 249, 7, 135, 0, 0, 0, 0, 195, 210, 5, 30, 2, 148,
        205, 167, 159, 122, 176, 22, 41, 106, 80, 76, 205, 162, 179, 53, 227, 132, 64, 184, 30, 54,
        155, 230, 246, 167, 48, 31, 192, 119, 68, 68, 161, 227, 253, 206, 129, 101, 10, 130, 103,
        133, 43, 97, 29, 246, 227, 31, 235, 49, 186, 175, 76, 205, 142, 187, 245, 76, 208, 180, 36,
        10, 200, 7, 12, 64, 173, 156, 18, 5, 51, 219, 197, 47, 248, 34, 2, 74, 231, 128, 59, 111,
        253, 90, 196, 16, 236, 118, 206, 7, 200, 98, 244, 75, 195, 116, 181, 26, 60, 192, 119, 237,
        161, 255, 176, 141, 217, 177, 183, 74, 185, 100, 186, 115, 165, 214, 72, 32, 101, 12, 186,
        33, 11, 142, 79, 206, 152, 158, 77, 2, 152, 0, 0, 0, 229, 69, 170, 160, 233, 50, 40, 76,
        19, 15, 225, 165, 50, 118, 39, 85, 21, 153, 204, 93, 51, 169, 99, 60, 219, 195, 236, 156,
        157, 9, 214, 119, 92, 200, 55, 155, 164, 150, 175, 28, 130, 253, 121, 97, 107, 235, 110,
        227, 2, 0, 0, 0, 32, 0, 0, 0, 207, 143, 106, 136, 116, 20, 70, 25, 234, 201, 120, 150, 224,
        121, 148, 37, 46, 17, 140, 242, 4, 227, 201, 76, 90, 219, 254, 25, 82, 234, 219, 157, 224,
        94, 170, 178, 101, 147, 92, 107, 34, 237, 155, 153, 117, 142, 225, 157, 243, 49, 215, 111,
        31, 115, 143, 220, 130, 237, 99, 70, 88, 238, 253, 160, 198, 208, 167, 226, 157, 79, 151,
        49, 72, 242, 175, 40, 200, 179, 238, 39, 186, 245, 133, 1, 221, 4, 178, 239, 42, 118, 229,
        101, 221, 5, 40, 145, 41, 172, 201, 82, 189, 249, 222, 197,
    ];
    let package2 = PublicPackage::deserialize_from(&package2_bytes[..]).unwrap();

    let round2_public_packages_1_bytes = [
        114, 74, 119, 222, 130, 99, 78, 38, 205, 60, 41, 201, 219, 43, 52, 110, 44, 77, 173, 209,
        211, 24, 150, 205, 114, 137, 152, 201, 0, 183, 124, 109, 217, 186, 199, 249, 57, 92, 215,
        245, 13, 84, 15, 12, 2, 145, 174, 16, 115, 127, 131, 134, 108, 3, 187, 108, 223, 118, 252,
        46, 179, 12, 114, 174, 6, 33, 84, 161, 211, 175, 30, 62, 150, 14, 99, 245, 180, 206, 227,
        15, 89, 135, 196, 8, 48, 174, 82, 34, 131, 224, 227, 229, 236, 53, 45, 160, 195, 219, 83,
        102, 188, 78, 188, 109, 127, 118, 109, 22, 158, 77, 185, 84, 134, 139, 247, 42, 127, 100,
        22, 154, 224, 89, 50, 178, 221, 238, 78, 14, 1, 1, 0, 0, 0, 114, 47, 118, 27, 67, 116, 82,
        234, 125, 80, 5, 23, 107, 34, 74, 188, 122, 185, 128, 46, 84, 194, 85, 11, 196, 124, 42,
        106, 198, 207, 178, 239, 125, 211, 153, 172, 15, 45, 165, 83, 238, 112, 106, 39, 38, 123,
        27, 222, 78, 247, 136, 167, 178, 166, 93, 241, 204, 143, 54, 49, 94, 198, 146, 12, 2, 235,
        110, 74, 14, 199, 134, 138, 59, 77, 169, 1, 110, 37, 162, 251, 43, 189, 252, 47, 247, 111,
        184, 115, 0, 100, 222, 32, 198, 254, 196, 5, 112, 235, 166, 222, 145, 16, 158, 63, 146, 80,
        140, 77, 2, 95, 159, 242, 57, 82, 138, 247, 33, 155, 8, 11, 62, 221, 227, 105, 197, 113,
        214, 249, 7, 37, 0, 0, 0, 0, 195, 210, 5, 30, 237, 226, 102, 157, 182, 146, 138, 73, 193,
        13, 54, 133, 21, 2, 246, 239, 170, 162, 22, 24, 231, 39, 108, 228, 218, 39, 189, 152, 214,
        24, 6, 7, 70, 179, 121, 150, 186, 9, 225, 164,
    ];
    let round2_public_packages_1 =
        CombinedPublicPackage::deserialize_from(&round2_public_packages_1_bytes[..]).unwrap();

    let round2_public_packages_2_bytes = [
        114, 47, 118, 27, 67, 116, 82, 234, 125, 80, 5, 23, 107, 34, 74, 188, 122, 185, 128, 46,
        84, 194, 85, 11, 196, 124, 42, 106, 198, 207, 178, 239, 125, 211, 153, 172, 15, 45, 165,
        83, 238, 112, 106, 39, 38, 123, 27, 222, 78, 247, 136, 167, 178, 166, 93, 241, 204, 143,
        54, 49, 94, 198, 146, 12, 2, 235, 110, 74, 14, 199, 134, 138, 59, 77, 169, 1, 110, 37, 162,
        251, 43, 189, 252, 47, 247, 111, 184, 115, 0, 100, 222, 32, 198, 254, 196, 5, 112, 235,
        166, 222, 145, 16, 158, 63, 146, 80, 140, 77, 2, 95, 159, 242, 57, 82, 138, 247, 33, 155,
        8, 11, 62, 221, 227, 105, 197, 113, 214, 249, 7, 1, 0, 0, 0, 114, 74, 119, 222, 130, 99,
        78, 38, 205, 60, 41, 201, 219, 43, 52, 110, 44, 77, 173, 209, 211, 24, 150, 205, 114, 137,
        152, 201, 0, 183, 124, 109, 217, 186, 199, 249, 57, 92, 215, 245, 13, 84, 15, 12, 2, 145,
        174, 16, 115, 127, 131, 134, 108, 3, 187, 108, 223, 118, 252, 46, 179, 12, 114, 174, 6, 33,
        84, 161, 211, 175, 30, 62, 150, 14, 99, 245, 180, 206, 227, 15, 89, 135, 196, 8, 48, 174,
        82, 34, 131, 224, 227, 229, 236, 53, 45, 160, 195, 219, 83, 102, 188, 78, 188, 109, 127,
        118, 109, 22, 158, 77, 185, 84, 134, 139, 247, 42, 127, 100, 22, 154, 224, 89, 50, 178,
        221, 238, 78, 14, 1, 37, 0, 0, 0, 0, 195, 210, 5, 30, 79, 35, 182, 62, 15, 209, 186, 166,
        254, 26, 226, 120, 251, 211, 81, 47, 123, 121, 42, 248, 184, 84, 158, 223, 160, 12, 123,
        187, 138, 64, 17, 9, 70, 179, 121, 150, 186, 9, 225, 164,
    ];
    let round2_public_packages_2 =
        CombinedPublicPackage::deserialize_from(&round2_public_packages_2_bytes[..]).unwrap();

    let (key_package, public_key_package, group_secret_key) = round3::round3(
        &secret,
        &encrypted_secret_package,
        [&package1, &package2],
        [&round2_public_packages_1, &round2_public_packages_2],
    )
    .unwrap();

    let key_package_slice = &key_package.serialize().unwrap()[..];
    if display {
        if !ui_display_secret(&key_package_slice)? {
            return Err(AppSW::Deny);
        }
    }

    // Send the data in chunks
    // send_apdu_chunks(comm, &key_package_slice)?;
    comm.append(&key_package_slice);

    Ok(())
}
